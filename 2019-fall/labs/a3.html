<!DOCTYPE html>
<meta charset="utf-8">

<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.8.0/github-markdown.min.css">

<style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
</style>

<title>Advanced Lab 3 - Pre-install Setup and Installation - Hands-On Linux System Administration DeCal</title>

<article class="markdown-body">
  <h1>Advanced Lab 3 - Pre-install Setup and Installation</h1>
  <p>In this lab we will be installing Arch Linux into a virtual machine.
In this lab you will need to pay close attention to detail: mistakes
may not be apparent for quite a while later, and can cause <em>huge</em>
headaches. As always, make sure to take advantage of Piazza and other
resources if you need help! Also, in this lab, the
<a href="https://wiki.archlinux.org">ArchWiki</a> will be an invaluable resource
that we will be referencing a lot.</p>

<blockquote>
  <p>Throughout the lab, additional notes will be formatted like this.
These notes are the <em>only</em> sections of the lab that you can safely
skip. They will provide additional interesting information and
context, so I recommend reading them anyway!</p>
</blockquote>

<p>As always, you will need to submit this lab on Gradescope. Any time
you see “<strong>GRADESCOPE:</strong>” in this lab, stop and make sure that you
have submitted the relevant answer or output to Gradescope. In most
cases, it will be <strong>hard or impossible</strong> to go back and get the answer
later in the lab.</p>

<blockquote>
  <p>We chose to install Arch Linux in this lab for a few reasons. First,
Arch Linux gives you tools to handle monotonous tasks (like
<code class="highlighter-rouge">genfstab</code>, which does the dirty work of writing out <code class="highlighter-rouge">/etc/fstab</code>)
while leaving the more complicated and more customizable tasks to
you. Second, Arch is widely used and experience with Arch can
usually be applied to other distributions as well. Third,
ArchWiki. Seriously. It’s that good.</p>
</blockquote>

<h2 id="setup">setup</h2>

<p>We will be setting up virtual machine <em>inside</em> your student VM.</p>

<blockquote>
  <p>Yes, this is a “nested” virtual machine.</p>
</blockquote>

<p>First, connect to your student VM using the credentials that were
emailed to you. If you haven’t yet, you will need to reset your
password when you first log in. Please use a <a href="https://xkcd.com/936">safe
password</a> and don’t lose it!</p>

<blockquote>
  <p>If you’re enrolled in this DeCal, you should have a student VM. If
you’re not, we can’t guarantee that these techniques will work on
other systems (for a variety of reasons). However, you can obtain a
system that’s very similar to a student VM by creating a Droplet on
DigitalOcean. Normally this Droplet would cost some amount of money,
but you can get free DigitalOcean credits by using the <a href="https://education.github.com/pack">GitHub
Student Developer Pack</a>. You can
follow <a href="https://www.digitalocean.com/docs/droplets/how-to/create/">the instructions on the DigitalOcean
website</a>
to create the Droplet. When selecting an image, choose Ubuntu 18.04.</p>
</blockquote>

<p>Now that you are connected to your student VM, we will need to install
some packages that will allow us to create our nested Arch Linux VM.
Run</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt install <span class="nt">--no-install-recommends</span> qemu-kvm qemu-utils libvirt-bin virtinst ovmf
</code></pre></div></div>

<blockquote>
  <p>QEMU is a system for running virtual machines, and it can use KVM,
which is a kernel module that supports the virtualization under the
hood. We can install this with the package <code class="highlighter-rouge">qemu-kvm</code>. <code class="highlighter-rouge">libvirt</code>
(installed via <code class="highlighter-rouge">libvirt-bin</code>) is a system for managing these
QEMU/KVM virtual machines. <code class="highlighter-rouge">qemu-utils</code> provides necessary tools for
creating virtual drives, and is used by <code class="highlighter-rouge">virt-install</code>. <code class="highlighter-rouge">virtinst</code>
will provide the script <code class="highlighter-rouge">virt-install</code>, which we will use to create
the virtual machine. We add <code class="highlighter-rouge">--no-install-recommends</code> because
<code class="highlighter-rouge">virtinst</code> has a recommended dependency <code class="highlighter-rouge">virt-viewer</code>, which depends
on the <a href="https://en.wikipedia.org/wiki/X_Window_System">X11 system</a>.
However, this is a lot of packages that are only useful if we have a
GUI (which we don’t!) so we want to skip recommended dependencies.
Finally, <code class="highlighter-rouge">ovmf</code> is an additional library that will let us use
<a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface">UEFI</a>
(instead of the older BIOS spec) to boot the VM.</p>
</blockquote>

<h3 id="acquire-installation-media">acquire installation media</h3>

<p>Next, we need to get the installation media. Download this, as well as
a signature that we will use to verify the authenticity of the media,
using the following commands:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget <span class="s1">'https://mirrors.ocf.berkeley.edu/archlinux/iso/2019.09.01/archlinux-2019.09.01-x86_64.iso'</span>
wget <span class="s1">'https://mirrors.ocf.berkeley.edu/archlinux/iso/2019.09.01/archlinux-2019.09.01-x86_64.iso.sig'</span>
</code></pre></div></div>

<p>You can run <code class="highlighter-rouge">ls</code> to see the two files that were downloaded.</p>

<p>Notice that we are downloading this from the OCF software mirrors
(<code class="highlighter-rouge">mirrors.ocf.berkeley.edu</code>). There’s nothing stopping the OCF from
modifying the <code class="highlighter-rouge">.iso</code> file and inserting malicious code that will end
up running on our machine. To avoid this, we need to verify that the
signature we downloaded is valid, and matches the file we downloaded.
For more info, see
<a href="https://wiki.archlinux.org/index.php/Installation_guide#Verify_signature">https://wiki.archlinux.org/index.php/Installation_guide#Verify_signature</a>.</p>

<p>To verify the signature, run <code class="highlighter-rouge">gpg --keyserver-options
auto-key-retrieve --verify file.sig</code>, replacing <code class="highlighter-rouge">file.sig</code> with the
downloaded <code class="highlighter-rouge">.sig</code> file. You’ll see information about who created this
signature. We want to know that this signature is from an Arch Linux
developer. To be pretty confident of that, go to
<a href="https://www.archlinux.org/people/developers/">https://www.archlinux.org/people/developers/</a>
and find the developer who is said to have created this
signature. Under their info click on the link that says “PGP
Key”. You’ll see a bunch of info about their PGP key. Check that the
“Fingerprint” listed near the top of this page matches the “Primary
key fingerprint” in the <code class="highlighter-rouge">gpg</code> output. If not, something is very
wrong!</p>

<p><strong>GRADESCOPE</strong>: Who is the developer that created this signature, and
what is their key’s fingerprint?</p>

<blockquote>
  <p>Note that this test is only resilient if www.archlinux.org is <em>not</em>
compromised. To be more confident, you might want to try to find
this fingerprint somewhere else, or independently verify this key
somehow. Traditionally this is done via the <a href="https://en.wikipedia.org/wiki/Web_of_trust">web of
trust</a>, but new systems
such as <a href="https://keybase.io">Keybase</a> are trying to find alternate
solutions to this fundamental problem of “How do I know you are who
you say you are?”</p>
</blockquote>

<h3 id="create-vm">create VM</h3>

<p>Now, we need to actually create our VM. <em>(Don’t run this command until
you’ve read the next paragraph!)</em> To do this, you will run</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>virt-install <span class="nt">--name</span> archvm <span class="nt">--memory</span> 512 <span class="nt">--cpu</span> host <span class="nt">--vcpus</span> 1 <span class="nt">--disk</span> <span class="nv">size</span><span class="o">=</span>5 <span class="nt">--network</span> <span class="nv">network</span><span class="o">=</span>default <span class="nt">--boot</span> uefi <span class="nt">--graphics</span> none <span class="nt">--cdrom</span> archlinux-2019.09.01-x86_64.iso
</code></pre></div></div>

<p>This will do some initial setup, and then drop us into a virtual
serial console connected to the VM. You’ll see some boot options and a
timer. Press <code class="highlighter-rouge">e</code> to edit the first boot option before the timer runs
out! By default, Arch will not enable the serial console we are
currently using to connect to the VM, so we need to manually add it to
the kernel command line. Once we’re editing this command line, hit
<code class="highlighter-rouge">END</code> to jump to the end of the line and carefully add a space and
then <code class="highlighter-rouge">console=ttyS0</code>. When you’re confident you’ve typed it right, hit
enter to start booting the kernel.</p>

<blockquote>
  <p>Normally, we use “terminal emulators” (like Terminal or iTerm on
Mac, or GNOME Terminal or Terminator on Linux) to access the
console. Alternatively, we can use the console via terminals running
via a keyboard and display. (To see this, hit <code class="highlighter-rouge">ctrl-alt-F1</code> on an
OCF lab computer. Hit <code class="highlighter-rouge">ctrl-alt-F7</code> to get back to the GUI.) The
option we are using here is accessing the console via a serial port
connection, which in the modern age is pretty rare. However, we’re
not using a real serial port of course—since we’re using a virtual
machine, the serial port is also virtualized. libvirt provides
convenient this convenient tooling to connect to this virtual serial
port from the console we already have with the host machine (your
student VM).</p>
</blockquote>

<p>We’re communicating with the VM via this virtual serial connection. If
you wanted to detatch from this, you would hit the key combo <code class="highlighter-rouge">ctrl-]</code>,
and reconnect by running the command <code class="highlighter-rouge">sudo virsh console archvm</code>.</p>

<blockquote>
  <p>In most cases if you disconnect and have to restart in the middle,
you can just run <code class="highlighter-rouge">sudo virsh console archvm</code> to reconnect. If you
really mess up, you can start things over by stopping the VM
(<code class="highlighter-rouge">sudo virsh destroy archvm</code>), deleting the VM
(<code class="highlighter-rouge">sudo virsh undefine archvm --nvram --remove-all-storage</code>), and
then recreating it by starting over from the command above. If for
some reason, your VM gets turned off before you are done installing
Arch, it may be possible to reconnect the archiso and reboot the VM
using the archiso. However, doing this is out of scope for this lab.</p>
</blockquote>

<p>You should start seeing a bunch of lines that start with <code class="highlighter-rouge">[   OK   ]</code>,
and eventually you will see a login prompt.</p>

<blockquote>
  <p>Since the installation media is basically just a preinstalled Linux
system that makes it easy to install Linux on another system, this
is the info about the booting “archiso” system. So, nothing is
actually installed on the VM yet, but we are booting into a
temporary Linux system that will help us install Linux permanently
on the VM.</p>
</blockquote>

<p>Once you see a login prompt, enter <code class="highlighter-rouge">root</code> as the username, and you
should get in! You’re now at the archiso command line.</p>

<p><strong>GRADESCOPE</strong>: Use the <code class="highlighter-rouge">hostname</code> command to get the current
hostname. What is it? Then, use <code class="highlighter-rouge">ip addr</code> to find the current IP
address (look at the <code class="highlighter-rouge">inet</code> line under <code class="highlighter-rouge">ens2</code>, it’s the stuff at the
beginning of the line, not including the <code class="highlighter-rouge">/24</code>). What is your IP
address? In another terminal, try to ping this IP address from your
student VM, and then also from tsunami (ssh.ocf.berkeley.edu). Can
either of them reach it?</p>

<blockquote>
  <p>We’ll discuss networking, and why you see these results, in a later
lecture.</p>
</blockquote>

<blockquote>
  <p>Notice we are booted using UEFI (hence <code class="highlighter-rouge">-boot uefi</code> in the
virt-install line). Check out the ArchWiki
(<a href="https://wiki.archlinux.org/index.php/Installation_guide#Verify_the_boot_mode">https://wiki.archlinux.org/index.php/Installation_guide#Verify_the_boot_mode</a>)
for more info. Also, notice that we are already connected to the
internet! Our virtual network uses DHCP, and the archiso knows to
try to autoconfigure using DHCP. We will talk more about DHCP and
other networking configuration later in the course. Finally, notice
that we’ve conveniently inherited the system clock, so the time
inside the VM should be right. You can run <code class="highlighter-rouge">date</code> to see.</p>
</blockquote>

<h2 id="partitioning-time">partitioning time</h2>

<p>The first order of business is to set up the partitions that we will
be using for this installation. We are going to use a simple parition
scheme:</p>
<ul>
  <li>an EFI system partition (ESP)</li>
  <li>one encrypted partition that holds our root filesystem</li>
  <li>a small partition for swap space</li>
</ul>

<p>This is a very common scheme and is totally a scheme you could use if
you were installing Arch on your own computer (except that you’ll
hopefully have more than 5GiB to work with)!</p>

<h3 id="create-partitions">create partitions</h3>

<p>We will use <code class="highlighter-rouge">fdisk</code> to create our partitions. Run <code class="highlighter-rouge">fdisk /dev/sda</code> to start.</p>

<blockquote>
  <p>Note that you’ll be making a bunch of changes to the parition table,
but these changes are not made immediately. So, if you make a
mistake, you can just start again from step 1 without damaging
anything.</p>
</blockquote>

<ol>
  <li>Create a GPT table by typing <code class="highlighter-rouge">g</code> (then hit enter).</li>
  <li>Create your ESP by typing <code class="highlighter-rouge">n</code>. Use the default parition number and
first sector (just hit enter to automatically take the default).
For the last sector, type <code class="highlighter-rouge">+512M</code> to allocate 512MiB for the
partition.</li>
  <li>Type <code class="highlighter-rouge">t</code> to change the type of the new partition (parition 1) to
“EFI System”. You will have to list the types and find the right
ID. (Note: press <code class="highlighter-rouge">q</code> to get out of the list of filesystem types).</li>
  <li>Create your main root partition by typing <code class="highlighter-rouge">n</code> again. Use the
default partition number and first sector. To leave 512MiB at the
end of the disk for our swap partition, type <code class="highlighter-rouge">-512M</code> for the last
sector. (This partition should already have the correct type,
“Linux filesystem”, so you won’t need to change that.)</li>
  <li>Create your swap partition by typing <code class="highlighter-rouge">n</code> one last time, and just
take all the defaults.</li>
  <li>Type <code class="highlighter-rouge">t</code> to change the type of the swap partition (parition 3) to
“Linux swap”, as in step 3.</li>
  <li>Type <code class="highlighter-rouge">p</code> to show the current partition table with all the changes
you’ve made. You should see an “EFI System” partition that is
512MiB, a “Linux filesystem” partition that is 4GiB, and a “Linux
swap” partition that is 512MiB.</li>
  <li>If everything looks right, type <code class="highlighter-rouge">w</code> to finally actually write the
changes to disk.</li>
</ol>

<p>At this point, <code class="highlighter-rouge">fdisk</code> should exit.</p>

<p><strong>GRADESCOPE</strong>: To see your final results, run <code class="highlighter-rouge">fdisk -l /dev/sda</code> and
paste the output into Gradescope.</p>

<p>At this point, you’ve created the disk partitions, but nothing is on
them yet. Now we need to put the filesystems you will use on these
partitions!</p>

<h3 id="create-filesystems">create filesystems</h3>

<h4 id="esp">ESP</h4>

<p>The ESP (EFI System Partition) has to be in a FAT format. For more
information about the ESP, see
<a href="https://wiki.archlinux.org/index.php/EFI_system_partition">https://wiki.archlinux.org/index.php/EFI_system_partition</a>.</p>

<p>Your ESP should be <code class="highlighter-rouge">/dev/sda1</code> (refer back to output from
<code class="highlighter-rouge">fdisk -l /dev/sda</code>). Run <code class="highlighter-rouge">mkfs.fat -F32 /dev/sda1</code> to create the
FAT32 filesystem.</p>

<blockquote>
  <p>These instructions are straight from
<a href="https://wiki.archlinux.org/index.php/EFI_system_partition#Format_the_partition">https://wiki.archlinux.org/index.php/EFI_system_partition#Format_the_partition</a>.</p>
</blockquote>

<h4 id="root-partition">root partition</h4>

<p>Our root partition should be <code class="highlighter-rouge">/dev/sda2</code>.</p>

<p>We are going to encrypt the root partition. This makes things a bit
more complicated, but thankfully the ArchWiki will help us out!</p>

<blockquote>
  <p>Encryption is basically essentially in modern devices. If you do not
encrypt your drive, anyone who has access to that drive can simply
take it out of your machine and read everything on it. Your account
password doesn’t protect against anything. However, if you do use
encryption, you will not be able to get anything off the disk at all
without the encryption password.</p>
</blockquote>

<h5 id="wiping">wiping</h5>

<p>Before setting up the encrypted partition, we need to wipe the
partition with random data. The instructions below are based on
<a href="https://wiki.archlinux.org/index.php/Dm-crypt/Drive_preparation#dm-crypt_wipe_on_an_empty_disk_or_partition">the ArchWiki instructions</a>.</p>

<blockquote>
  <p>Why wipe your drive? You can tell the difference blank data on a
disk and encrypted data, but not between random data and encrypted
data. Filling the disk with random data before setting up the
encryption protects information such as how full the partition is.</p>
</blockquote>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cryptsetup open <span class="nt">--type</span> plain <span class="nt">-d</span> /dev/urandom /dev/sda2 to_be_wiped
dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/dev/mapper/to_be_wiped <span class="nv">status</span><span class="o">=</span>progress <span class="nv">bs</span><span class="o">=</span>1M
cryptsetup close to_be_wiped
</code></pre></div></div>

<blockquote>
  <p>This generates a random key and pretends that our partition is
encrypted with it. So, if we fill the entire encrypted drive with
zeros, it will fill the real drive with fake encrypted data
(indistinguishable from random data). This might take a sec to do!
Don’t worry.</p>
</blockquote>

<h5 id="setting-up-the-encrypted-device">setting up the encrypted device</h5>

<p>Again, this is taken from the ArchWiki. <a href="https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_an_entire_system#LUKS_on_a_partition">Follow
along!</a></p>

<p>First, set up the encrypted partition. For this lab, use the
encryption passphrase <code class="highlighter-rouge">ilovelinux</code>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cryptsetup <span class="nt">-y</span> <span class="nt">-v</span> luksFormat /dev/sda2
</code></pre></div></div>

<blockquote>
  <p>A note on passphrases: don’t use a passphrase like this! A good way
to come up with passphrases is just to take 6 random words (and I
mean actually random, not like
<a href="https://xkcd.com/1210">xkcd.com/1210</a> random). One way to generate
such a password is the command <code class="highlighter-rouge">shuf -n 6 /usr/share/dict/words</code>
(you might have to install a package like <code class="highlighter-rouge">wamerican</code> on
Ubuntu/Debian or <code class="highlighter-rouge">words</code> on Arch). We will talk more about security
(including password security) later in the course.</p>
</blockquote>

<p>Now that the encrypted partition has been created, let’s open it!</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cryptsetup open /dev/sda2 cryptroot
</code></pre></div></div>

<p><strong>GRADESCOPE</strong>: Run <code class="highlighter-rouge">lsblk</code> to see the hierarchy of these partitions.
Paste this output into Gradescope!</p>

<h5 id="creating-the-actual-filesystem">creating the actual filesystem</h5>

<p>We now have a blank pseudo-partition (“block device”)
<code class="highlighter-rouge">/dev/mapper/cryptroot</code>, that’s actually backed by encrypted
<code class="highlighter-rouge">/dev/sda2</code> disk parition. However, there’s no filesystem here
yet. Create it by doing</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkfs.ext4 /dev/mapper/cryptroot
</code></pre></div></div>

<p><strong>GRADESCOPE</strong>: What previous command we ran is similar to this
command, and what’s the difference? (Bonus: why?)</p>

<h4 id="swap">swap</h4>

<p>Our swap partition should be <code class="highlighter-rouge">/dev/sda3</code>. The swap space isn’t really
a <em>filesystem</em>, but we still need to set it up. Thankfully, this is
pretty straightforward:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkswap /dev/sda3
</code></pre></div></div>

<p>Then, enable it with</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swapon /dev/sda3
</code></pre></div></div>

<blockquote>
  <p>If you don’t know about swap, it is basically a specially designated
section of disk that the operating system can use as memory in case
it runs out of actual memory. For more info, check out
<a href="https://wiki.archlinux.org/index.php/Swap">https://wiki.archlinux.org/index.php/Swap</a>.</p>
</blockquote>

<h3 id="mount-the-new-filesystems">mount the new filesystems</h3>

<p>We’ve now created all our filesystems, but in order to access them, we
need to mount them. We’re going to use <code class="highlighter-rouge">/mnt</code> as the temporary root of
the new Arch installation. Thus, we mount the root filesystem at
<code class="highlighter-rouge">/mnt</code>, and the ESP at <code class="highlighter-rouge">/mnt/boot</code> (since the ESP will normally be
mounted at <code class="highlighter-rouge">/boot</code>). Hopefully this will make a little more sense once
we begin installing the system.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mount /dev/mapper/cryptroot /mnt
mkdir /mnt/boot
mount /dev/sda1 /mnt/boot
</code></pre></div></div>

<p><strong>GRADESCOPE</strong>: You can see every single filesystem that’s currently
mounted by running the <code class="highlighter-rouge">mount</code> command. Run it, and look for the two
filesystems we just mounted. Copy all the output over to Gradescope.</p>

<h2 id="installation">Installation</h2>

<p>With our partitions all set up and ready to get going, we can start
installing out system onto them!</p>

<blockquote>
  <p>Much of this will be straight from the ArchWiki installation guide,
starting at
<a href="https://wiki.archlinux.org/index.php/Installation_guide#Installation">https://wiki.archlinux.org/index.php/Installation_guide#Installation</a>.
It’s a good idea to follow along there as well to see what
modifications we are making.</p>
</blockquote>

<h3 id="mirrors">mirrors</h3>

<p>We need to tell Arch which software mirror to use when downloading
packages. Go ahead and just put the OCF mirror at the top! Edit
<code class="highlighter-rouge">/etc/pacman.d/mirrorlist</code> using <code class="highlighter-rouge">vim</code>/<code class="highlighter-rouge">emacs</code>/<code class="highlighter-rouge">nano</code> and put the
following line at the top:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Server = https://mirrors.ocf.berkeley.edu/archlinux/$repo/os/$arch
</code></pre></div></div>

<p>(We’re usually lower down in the file but putting us at the top will
make things a bit faster to install.)</p>

<h3 id="continue-according-to-archwiki">continue according to ArchWiki!</h3>

<p>Follow the arch wiki exactly from
<a href="https://wiki.archlinux.org/index.php/Installation_guide#Install_the_base_packages">https://wiki.archlinux.org/index.php/Installation_guide#Install_the_base_packages</a>
down until you get to the “Initramfs” section. If you get stuck, check
out the following hints:</p>

<ul>
  <li><code class="highlighter-rouge">vim</code> is not installed in the chroot by default. You can do
<code class="highlighter-rouge">pacman -S vim</code> to install it, or just use plain old <code class="highlighter-rouge">vi</code>.</li>
  <li>Our timezone is <code class="highlighter-rouge">America/Los_Angeles</code>.</li>
  <li>The locale you want to use is <code class="highlighter-rouge">en_US.UTF-8</code>.</li>
  <li>You shouldn’t need to change the keyboard layout.</li>
  <li>You can pick whatever you want for your hostname. OCF machines are
all named after “disasters”, so it can be fun to come up with a
creative name that fit that theme.</li>
</ul>

<h3 id="initramfs">initramfs</h3>

<p>The initramfs is the minimal stuff that’s loaded into RAM that helps
Linux get started when you first boot. On Arch, there’s a system to
generate this initramfs. You need to tell it to support disk
encryption.</p>

<p>Based on the <a href="https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_an_entire_system#Configuring_mkinitcpio">ArchWiki’s
instructions</a>,
we need to edit <code class="highlighter-rouge">/etc/mkinitcpio.conf</code>. You should see a line like</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HOOKS=(base udev autodetect ...)
</code></pre></div></div>

<p>We need to add the <code class="highlighter-rouge">keymap</code> and <code class="highlighter-rouge">encrypt</code> hooks, and move the
<code class="highlighter-rouge">keyboard</code> hook earlier in the line. When you’re done, it should look
like</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HOOKS=(base udev autodetect keyboard keymap modconf block encrypt filesystems fsck)
</code></pre></div></div>

<p>The <em>order</em> of these hooks matters! Be careful.</p>

<p>Run <code class="highlighter-rouge">mkinitcpio -p linux</code> to generate the new initramfs based on the
new config file.</p>

<h3 id="root-password">root password</h3>

<p>Use <code class="highlighter-rouge">passwd</code> to set the root password to <code class="highlighter-rouge">itoolovelinux</code>.</p>

<blockquote>
  <p>As mentioned for the disk encryption passphrase, don’t use a
password like this in real life! Choose a strong root password using
a method like the one from earlier. User programs shouldn’t be able
to compromise this password, because it would allow a single program
(which should generally be untrusted) to access everything on your
computer.</p>
</blockquote>

<h3 id="boot-loader">boot loader</h3>

<p>Historically, GRUB has been the only reasonable choice of boot
loader. However, with the advent of UEFI, there are lots of different
good options (or my personal favorite, no bootloader at all). In this
lab, we are going to use
<a href="https://wiki.archlinux.org/index.php/Systemd-boot">systemd-boot</a>.</p>

<p>We can install systemd-boot to our ESP by running</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bootctl <span class="nt">--path</span><span class="o">=</span>/boot install
</code></pre></div></div>

<p>We now need to tell systemd-boot that our Arch Linux installation
exists and how to start it! Create a bootloader entry by creating the file
<code class="highlighter-rouge">/boot/loader/entries/arch.conf</code> with these contents:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>title   Arch Linux
linux   /vmlinuz-linux
initrd  /initramfs-linux.img
options cryptdevice=UUID=290d6a44-2964-48a0-a71e-ea3df0525987:cryptroot root=/dev/mapper/cryptroot rw console=ttyS0
</code></pre></div></div>

<p><strong>IMPORTANT NOTE:</strong> You will need to replace
<code class="highlighter-rouge">290d6a44-2964-48a0-a71e-ea3df0525987</code> with the correct UUID for your
encrypted <code class="highlighter-rouge">/dev/sda2</code> partition. To find the correct UUID, run <code class="highlighter-rouge">ls -l
/dev/disk/by-uuid</code> and look for the line with <code class="highlighter-rouge">-&gt; ../../sda2</code>. This
line will have the UUID you need. <strong>If you make a mistake here, you
can mess things up pretty bad! TRIPLE-CHECK this file!</strong></p>

<blockquote>
  <p>We could use a name like <code class="highlighter-rouge">/dev/sda2</code> instead of
<code class="highlighter-rouge">UUID=290d6a44-2964-48a0-a71e-ea3df0525987</code> here. However, these
names like <code class="highlighter-rouge">/dev/sdXX</code> are not guaranteed to always be the same. A
kernel update or hardware changes can mean that <code class="highlighter-rouge">/dev/sda2</code> is now
<code class="highlighter-rouge">/dev/sdb2</code>, or vice versa. This will mean we won’t be able to boot,
and in particularly bad cases, can lead to data loss. For this
reason, we should use UUIDs whenever possible, because they cannot
change. See
<a href="https://wiki.archlinux.org/index.php/Persistent_block_device_naming">https://wiki.archlinux.org/index.php/Persistent_block_device_naming</a>
for more info about this.</p>
</blockquote>

<blockquote>
  <p>Also, remember how we had to add <code class="highlighter-rouge">console=ttyS0</code> when we first
booted the archiso? We can add that option here to make it permanent
for the new system, so the console will always be enabled.</p>
</blockquote>

<p>Type <code class="highlighter-rouge">exit</code> to exit the chroot and then type `reboot** to REBOOT AND
FINISH THE INSTALLATION! Congrats!</p>

<blockquote>
  <p>If things don’t work after you reboot, don’t panic! Please make a
Piazza post or ask for help on Slack, and we will try to help you
recover things.</p>
</blockquote>

<p>When it reboots, you will be asked for the disk encryption password,
and then you should see a login prompt. Log in as root using the
password you set!</p>

<p><strong>GRADESCOPE</strong>: To show off your newly installed Arch system, run the
following commands and paste the output into Gradescope:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hostname -f
ip addr
mount
lsblk
uname -a
</code></pre></div></div>

<p>When you are done, you can hit <code class="highlighter-rouge">ctrl-]</code> to detach your console from
the Arch VM and get back to your normal student VM shell.</p>


  <br>
<footer>
  <div class="col-lg-12 text-center">
    <p>
      <a href="https://www.digitalocean.com">
        <img src="/images/digitalocean.png" style="height: 34px; width: 200px;" /></a>
      &nbsp;&nbsp;With great appreciation to
      <a href="https://www.digitalocean.com">DigitalOcean</a> for sponsoring the
      VMs used in both tracks of the DeCal
    </p>

    <p>
      <a href="https://www.ocf.berkeley.edu">
        <img src="https://www.ocf.berkeley.edu/hosting-logos/ocf-hosted-penguin.svg"
             alt="Hosted by the OCF" style="border: 0;" /></a>
      Copyright &copy; 2017-2019
      <a href="https://www.ocf.berkeley.edu">
        Open Computing Facility
      </a>
      and
      <a href="https://xcf.berkeley.edu">
        eXperimental Computing Facility
      </a>
    </p>
    <p>
      This website is licensed under the terms of the
      <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
        CC BY-NC-SA 4.0
      </a>
      License.
      <a href="https://github.com/0xcf/decal-web/">
        Source Code
      </a>
      available on GitHub
    </p>
  </div>
  <!-- /.col-lg-12 -->
</footer>

</article>

